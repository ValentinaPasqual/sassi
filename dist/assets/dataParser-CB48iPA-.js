const m="/sassi/";async function w(){try{const o=localStorage.getItem("mapConfig");if(o)return console.log("Loading configuration from localStorage (with updates)"),JSON.parse(o);const r=await(await fetch(`${m}/config/map-config.json`)).json();return console.log("Loaded configuration from server:",r),r}catch(o){throw console.error("Error loading configuration:",o),o}}async function y(o){try{return localStorage.setItem("mapConfig",JSON.stringify(o,null,2)),console.log("âœ… Configuration permanently saved to browser storage"),!0}catch(i){return console.error("Error saving configuration:",i),!1}}const h="/sassi/",p={config:{datasetConfig:{multivalue_rows:{},fields:{}}},async init(){try{const o=await w();return o?(this.config=o,this.config.datasetConfig?(this.config.datasetConfig.multivalue_rows||(this.config.datasetConfig.multivalue_rows={}),this.config.datasetConfig.fields||(this.config.datasetConfig.fields={})):this.config.datasetConfig={multivalue_rows:{},fields:{}}):console.warn("loadConfiguration returned undefined or null, using default config"),this}catch(o){return console.error("Error loading configuration:",o),console.warn("Using default configuration due to error"),this}},async saveConfig(){try{return await y(this.config),console.log("Configuration saved successfully with updated fields"),!0}catch(o){return console.error("Error saving configuration:",o),!1}},async parseData(){try{const[o,i]=await Promise.all([fetch(`${h}/data/catalogue.tsv`),fetch(`${h}/data/geodata.tsv`)]),[r,l]=await Promise.all([o.text(),i.text()]),s=this.parseTsvToJson(r),t=this.parseTsvToJson(l),e=s.length>0?Object.keys(s[0]):[],a=t.length>0?Object.keys(t[0]):[],n={catalogue:e,geodata:a,all:[...new Set([...e,...a])]},v=this.config.datasetConfig.fields;JSON.stringify(v)!==JSON.stringify(n)?(this.config.datasetConfig.fields=n,console.log("Dataset fields updated:",this.config.datasetConfig.fields),await this.saveConfig()?console.log("Fields permanently saved to config file"):console.warn("Failed to save fields to config file")):console.log("Fields unchanged, no need to update config file");let c=null;if(e.includes("Location")&&a.includes("Location")?c="Location":e.includes("Titolo")&&a.includes("Titolo")&&(c="Titolo"),!c)return console.warn("No common join field found. Available fields:"),console.warn("Catalogue fields:",e),console.warn("Geodata fields:",a),this.processMultivalueFields([...s,...t]);console.log(`Using "${c}" as join field`);const g=[];return t.forEach(f=>{const d=s.filter(u=>u[c]===f[c]);d.length>0?d.forEach(u=>{const C={...u,...f};g.push(C)}):g.push(f)}),this.processMultivalueFields(g)}catch(o){return console.error("Error in parseData:",o),[]}},processMultivalueFields(o){var r,l;const i=((l=(r=this.config)==null?void 0:r.datasetConfig)==null?void 0:l.multivalue_rows)||{};return o.forEach(s=>{Object.keys(i).forEach(t=>{if(s[t]&&typeof s[t]=="string"){const e=i[t];s[t]=s[t].split(e).map(a=>a.trim())}})}),o},parseTsvToJson(o){const i=o.trim().split(/\r?\n/),r=i[0].split("	").map(l=>l.trim());return i.slice(1).map(l=>{const s=l.split("	"),t={};return r.forEach((e,a)=>{if(a<s.length&&s[a]!==""){const n=s[a].replace(/\r/g,"").trim();if(n==="")return;n.toLowerCase()==="true"?t[e]=!0:n.toLowerCase()==="false"?t[e]=!1:!isNaN(n)&&n.trim()!==""?e==="Location"||e==="Titolo"?t[e]=n:t[e]=Number(n):t[e]=n}}),t})}},j=async()=>(await p.init(),p.parseData());export{w as l,j as p};
