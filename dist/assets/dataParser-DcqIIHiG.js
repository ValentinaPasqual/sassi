const m="/sassi/";async function w(){try{const o="mapConfig_sassi",e=localStorage.getItem(o);if(e)return console.log(`Loading configuration from localStorage (${o})`),JSON.parse(e);const n=await(await fetch(`${m}config/map-config.json`)).json();return console.log("Loaded configuration from server:",n),n}catch(o){throw console.error("Error loading configuration:",o),o}}async function y(o){try{const e="mapConfig_sassi";return localStorage.setItem(e,JSON.stringify(o,null,2)),console.log(`âœ… Configuration saved to ${e}`),!0}catch(e){return console.error("Error saving configuration:",e),!1}}const h="/sassi/",p={config:{datasetConfig:{multivalue_rows:{},fields:{}}},async init(){try{const o=await w();return o?(this.config=o,this.config.datasetConfig?(this.config.datasetConfig.multivalue_rows||(this.config.datasetConfig.multivalue_rows={}),this.config.datasetConfig.fields||(this.config.datasetConfig.fields={})):this.config.datasetConfig={multivalue_rows:{},fields:{}}):console.warn("loadConfiguration returned undefined or null, using default config"),this}catch(o){return console.error("Error loading configuration:",o),console.warn("Using default configuration due to error"),this}},async saveConfig(){try{return await y(this.config),console.log("Configuration saved successfully with updated fields"),!0}catch(o){return console.error("Error saving configuration:",o),!1}},async parseData(){try{const[o,e]=await Promise.all([fetch(`${h}/data/references.tsv`),fetch(`${h}/data/locations.tsv`)]),[l,n]=await Promise.all([o.text(),e.text()]),a=this.parseTsvToJson(l),s=this.parseTsvToJson(n),t=a.length>0?Object.keys(a[0]):[],i=s.length>0?Object.keys(s[0]):[],r={catalogue:t,geodata:i,all:[...new Set([...t,...i])]},v=this.config.datasetConfig.fields;JSON.stringify(v)!==JSON.stringify(r)?(this.config.datasetConfig.fields=r,console.log("Dataset fields updated:",this.config.datasetConfig.fields),await this.saveConfig()?console.log("Fields permanently saved to config file"):console.warn("Failed to save fields to config file")):console.log("Fields unchanged, no need to update config file");let c=null;if(t.includes("Location")&&i.includes("Location")?c="Location":t.includes("Titolo")&&i.includes("Titolo")&&(c="Titolo"),!c)return console.warn("No common join field found. Available fields:"),console.warn("Catalogue fields:",t),console.warn("Geodata fields:",i),this.processMultivalueFields([...a,...s]);console.log(`Using "${c}" as join field`);const g=[];return s.forEach(f=>{const d=a.filter(u=>u[c]===f[c]);d.length>0?d.forEach(u=>{const C={...u,...f};g.push(C)}):g.push(f)}),this.processMultivalueFields(g)}catch(o){return console.error("Error in parseData:",o),[]}},processMultivalueFields(o){var l,n;const e=((n=(l=this.config)==null?void 0:l.datasetConfig)==null?void 0:n.multivalue_rows)||{};return o.forEach(a=>{Object.keys(e).forEach(s=>{if(a[s]&&typeof a[s]=="string"){const t=e[s];a[s]=a[s].split(t).map(i=>i.trim())}})}),o},parseTsvToJson(o){const e=o.trim().split(/\r?\n/),l=e[0].split("	").map(n=>n.trim());return e.slice(1).map(n=>{const a=n.split("	"),s={};return l.forEach((t,i)=>{if(i<a.length&&a[i]!==""){const r=a[i].replace(/\r/g,"").trim();if(r==="")return;r.toLowerCase()==="true"?s[t]=!0:r.toLowerCase()==="false"?s[t]=!1:!isNaN(r)&&r.trim()!==""?t==="Location"||t==="Titolo"?s[t]=r:s[t]=Number(r):s[t]=r}}),s})}},j=async()=>(await p.init(),p.parseData());export{w as l,j as p};
