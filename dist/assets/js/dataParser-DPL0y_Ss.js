const h="/leda/";async function v(){try{const t=localStorage.getItem("mapConfig");if(t)return console.log("Loading configuration from localStorage (with updates)"),JSON.parse(t);const r=await(await fetch(`${h}/config/map-config.json`)).json();return console.log("Loaded configuration from server:",r),r}catch(t){throw console.error("Error loading configuration:",t),t}}async function m(t){try{return localStorage.setItem("mapConfig",JSON.stringify(t,null,2)),console.log("âœ… Configuration permanently saved to browser storage"),!0}catch(n){return console.error("Error saving configuration:",n),!1}}const g="/leda/",u={config:{datasetConfig:{multivalue_rows:{},fields:{}}},async init(){try{const t=await v();return t?(this.config=t,this.config.datasetConfig?(this.config.datasetConfig.multivalue_rows||(this.config.datasetConfig.multivalue_rows={}),this.config.datasetConfig.fields||(this.config.datasetConfig.fields={})):this.config.datasetConfig={multivalue_rows:{},fields:{}}):console.warn("loadConfiguration returned undefined or null, using default config"),this}catch(t){return console.error("Error loading configuration:",t),console.warn("Using default configuration due to error"),this}},async saveConfig(){try{return await m(this.config),console.log("Configuration saved successfully with updated fields"),!0}catch(t){return console.error("Error saving configuration:",t),!1}},async parseData(){try{const[t,n]=await Promise.all([fetch(`${g}/data/catalogue.tsv`),fetch(`${g}/data/geodata.tsv`)]),[r,i]=await Promise.all([t.text(),n.text()]),o=this.parseTsvToJson(r),e=this.parseTsvToJson(i),a=o.length>0?Object.keys(o[0]):[],c=e.length>0?Object.keys(e[0]):[],s={catalogue:a,geodata:c,all:[...new Set([...a,...c])]},d=this.config.datasetConfig.fields;JSON.stringify(d)!==JSON.stringify(s)?(this.config.datasetConfig.fields=s,console.log("Dataset fields updated:",this.config.datasetConfig.fields),await this.saveConfig()?console.log("Fields permanently saved to config file"):console.warn("Failed to save fields to config file")):console.log("Fields unchanged, no need to update config file");const f=new Map;o.forEach(l=>{l.ID_opera&&f.set(l.ID_opera,l)});const p=e.map(l=>({...f.get(l.ID_opera)||{},...l}));return this.processMultivalueFields(p)}catch(t){return console.error("Error in parseData:",t),[]}},processMultivalueFields(t){var r,i;const n=((i=(r=this.config)==null?void 0:r.datasetConfig)==null?void 0:i.multivalue_rows)||{};return t.forEach(o=>{Object.keys(n).forEach(e=>{if(o[e]&&typeof o[e]=="string"){const a=n[e];o[e]=o[e].split(a).map(c=>c.trim())}})}),t},parseTsvToJson(t){const n=t.trim().split(/\r?\n/),r=n[0].split("	").map(i=>i.trim());return n.slice(1).map(i=>{const o=i.split("	"),e={};return r.forEach((a,c)=>{if(c<o.length&&o[c]!==""){const s=o[c].replace(/\r/g,"").trim();if(s==="")return;s.toLowerCase()==="true"?e[a]=!0:s.toLowerCase()==="false"?e[a]=!1:!isNaN(s)&&s.trim()!==""?a==="ID_opera"?e[a]=s:e[a]=Number(s):e[a]=s}}),e})}},E=async()=>(await u.init(),u.parseData());export{v as l,E as p};
